% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/treatment.R
\name{estimate_counterfactual_ml}
\alias{estimate_counterfactual_ml}
\title{Estimate counterfactual performance of another algorithm}
\usage{
estimate_counterfactual_ml(
  data = NULL,
  aps = NULL,
  Y = NULL,
  Z = NULL,
  ml = NULL,
  mlnew = NULL,
  degen = c(0, 1),
  apslab = "APS",
  ylab = "Y",
  zlab = "Z",
  mllab = "ML1",
  mlnewlab = "ML2",
  verbose = T
)
}
\arguments{
\item{data}{Dataset containing APS, Y, Z, the original ML algorithm predictions,
and the counterfactual ML' algorithm predictions.}

\item{aps}{Vector of APS values.}

\item{Y}{Vector of outcome values.}

\item{Z}{Vector of ML recommendation values.}

\item{ml}{Vector of ML predictions.}

\item{mlnew}{Vector of counterfactual ML predictions.}

\item{degen}{Vector of values for which APS is degenerate. Defaults to c(0,1).}

\item{apslab}{Column name of APS variable. Defaults to "APS".}

\item{ylab}{Column name of Y variable. Defaults to "Y".}

\item{zlab}{Column name of Z variable. Defaults to "Z".}

\item{mllab}{Column name of original ML prediction variable. Defaults to "ML1".}

\item{mlnewlab}{Column name of counterfactual ML prediction variable. Defaults to "ML2".}

\item{verbose}{Boolean indicator for whether to print summary output of estimation. Defaults to True.}
}
\value{
List containing counterfactual predictions and fitted lm model object.
}
\description{
Estimate counterfactual performance of another algorithm
}
\details{
The process of estimating counterfactual value works as follows. First we we fit the
below OLS regression using historical recommendations and outcome \code{Z} and \code{Y}.
\deqn{Y_i = \beta_0 + \beta_1 Z_i + \beta_2 p^s(X_i; \delta) + \epsilon_i}
where \eqn{\beta_1} is our estimated effect of treatment recommendation.

Then we take the original algorithm output \code{ml} and the counterfactual algorithm output \code{mlnew}
and estimate the below value equation.
\deqn{\hat{V}(ML') = \frac{1}{n} \sum_{i=1}^n (Y_i + \hat{\beta_{ols}}(ML'(X_i) - ML(X_i)))}
}
\examples{
library(mlr3)
data("iris")
assign_cutoff <- function(X, cutoff){
  ret <- as.integer(X > cutoff)
  return(ret)
}
test_data <- iris
model <- lm(Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width, data=test_data)
ml <- predict(model, test_data)
task_iris <- TaskRegr$new(id="iris", backend=test_data[,1:4], target="Sepal.Length")
learner = lrn("regr.rpart")
learner$train(task_iris)
mlnew <- predict(learner, test_data)
aps <- estimate_aps(test_data, model, xc = names(test_data)[2:4],
           infer=FALSE, s=400, delta=0.8, fcn=assign_cutoff, cutoff = 6)
# Can send counterfactual estimation inputs in two different ways
Y_val <- test_data$Sepal.Length
Z_val <- assign_cutoff(iris$Sepal.Length, 6)
test_data[, Y := Y_val]
test_data[, Z := Z_val]
test_data[, ml := ml]
test_data[, ml_new := mlnew]
test_data[, APS := aps]
estimate_counterfactual_ml(aps = aps, Y = Y_val, Z = Z_val, ml = ml, mlnew = mlnew)
estimate_counterfactual_ml(test_data, apslab = "APS", ylab = "Y", zlab = "Z",
                      mllab = "ml", mlnewlab = "ml_new")
}
